package com.albertattard.presentation.contacts

import io.kotlintest.shouldBe
import io.kotlintest.shouldThrow
import io.kotlintest.specs.StringSpec
import io.micronaut.core.type.Argument
import io.micronaut.http.HttpHeaders
import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpStatus
import io.micronaut.http.client.RxHttpClient
import io.micronaut.http.client.annotation.Client
import io.micronaut.http.client.exceptions.HttpClientResponseException
import io.micronaut.test.annotation.MicronautTest
import io.micronaut.test.annotation.MockBean
import io.micronaut.test.extensions.kotlintest.MicronautKotlinTestExtension.getMock
import io.mockk.confirmVerified
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import java.util.UUID

@MicronautTest
class ContactsControllerTest(
    private val service: ContactsService,
    @Client("/contacts") private val client: RxHttpClient
) : StringSpec({
    "should create contact and return the resource link a generated by the greeting service" {
        val mock = getMock(service)

        val create = CreateContact(name = "Albert Attard", email = "albertattard@gmail.com")

        val created =
            CreatedContact(UUID.randomUUID())
        every { mock.create(create) } returns created

        val response = client.toBlocking().exchange(HttpRequest.POST("/", create), CreatedContact::class.java)
        response.status shouldBe HttpStatus.CREATED
        response.headers[HttpHeaders.LOCATION] shouldBe "/contacts/${created.id}"

        verify(exactly = 1) { mock.create(create) }

        /* TODO: check why this needs to be verified */
        verify(exactly = 2) { mock.hashCode() }
        verify(exactly = 1) { mock.toString() }
        confirmVerified(mock)
    }

    "should return not found if contact is not found" {
        val mock = getMock(service)

        val id = UUID.randomUUID()
        every { mock.findById(id) } returns null

        val exception = shouldThrow<HttpClientResponseException> {
            client.toBlocking().retrieve(HttpRequest.GET<Any>("/$id"))
        }
        exception.status.code shouldBe 404

        verify(exactly = 1) { mock.findById(id) }

        /* TODO: check why this needs to be verified */
        verify(exactly = 2) { mock.hashCode() }
        verify(exactly = 1) { mock.toString() }
        confirmVerified(mock)
    }

    "should return the contact when found" {
        val mock = getMock(service)

        val id = UUID.randomUUID()
        val contact = Contact(id = id, name = "Albert Attard", email = "albertattard@gmail.com")

        every { mock.findById(id) } returns contact

        val response = client.toBlocking().retrieve(HttpRequest.GET<Any>("/$id"), Contact::class.java)
        response shouldBe contact

        verify(exactly = 1) { mock.findById(id) }

        /* TODO: check why this needs to be verified */
        verify(exactly = 2) { mock.hashCode() }
        verify(exactly = 1) { mock.toString() }
        confirmVerified(mock)
    }

    "should return the list of contacts" {
        val mock = getMock(service)

        val contacts = listOf(
            Contact(id = UUID.randomUUID(), name = "Albert Attard", email = "albertattard@gmail.com")
        )
        every { mock.list() } returns contacts

        val response = client.toBlocking()
            .retrieve(HttpRequest.GET<Any>("/"), Argument.of(MutableList::class.java, Contact::class.java))
        response shouldBe contacts

        verify(exactly = 1) { mock.list() }

        /* TODO: check why this needs to be verified */
        verify(exactly = 2) { mock.hashCode() }
        verify(exactly = 1) { mock.toString() }
        confirmVerified(mock)
    }
}) {
    @MockBean(ContactsService::class)
    fun contactsService(): ContactsService {
        return mockk()
    }
}
